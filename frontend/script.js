/**
 * THIS FILE WAS GENERATED BY FIGMA'S DESIGN-TO-CODE PLUGIN, WITH FILE DESTINATIONS INCLUDED AFTERWARDS
 * 
 * 
 * Main application script for crypto trading bot frontend with authentication
 * 
 * Citations:
 * - Fetch API for HTTP requests: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
 * - DOM manipulation: https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model
 * - SessionStorage for auth tokens: https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
 * - JavaScript intervals: https://developer.mozilla.org/en-US/docs/Web/API/setInterval
 * - Form validation patterns: https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation
 */

// Configuration constants - centralized config management
const DEFAULT_CONFIG = {
    tradeSize: 0.01,
    stopLoss: 2.0,
    stopProfit: 2.5,
    rsiBuy: 30,
    rsiSell: 70,
    macdBuy: 0.0,
    macdSell: 0.0,
    positionSize: 100.0,
    loopInterval: 60,
    indicatorWindow: 26,
    active: 1
};

const API_BASE_URL = 'http://localhost:5000';

// Application state - tracks dynamic system behavior
let lastConnectionCheck = null;
let currentLoopInterval = 60; // synced with backend loop timing
let statusCheckInterval = null;
let tradesRefreshInterval = null;

/**
 * Get authentication headers for API calls
 * Retrieves JWT token from session storage for authenticated requests
 */
function getAuthHeaders() {
    const token = sessionStorage.getItem('authToken');
    return {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
    };
}

/**
 * Handle authentication errors by redirecting to login
 * Provides centralized auth error handling across the app
 */
function handleAuthError(response) {
    if (response.status === 401) {
        console.log('üîê Authentication expired, redirecting to login...');
        sessionStorage.removeItem('authToken'); // cleanup expired token
        sessionStorage.removeItem('username');
        window.location.href = 'login.html';
        return true;
    }
    return false;
}

/**
 * Make authenticated API request with error handling
 * Wrapper around fetch that handles auth and provides consistent error handling
 */
async function authenticatedFetch(url, options = {}) {
    const authHeaders = getAuthHeaders();
    
    const requestOptions = {
        ...options,
        headers: {
            ...authHeaders,
            ...options.headers
        }
    };
    
    console.log('üì° Making authenticated request to:', url);
    const response = await fetch(url, requestOptions);
    
    if (handleAuthError(response)) {
        throw new Error('Authentication failed');
    }
    
    return response;
}

/**
 * Initialize application when DOM is ready
 * Entry point for frontend application setup
 */
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Main application initializing...');
    
    // only proceed if user is authenticated
    if (sessionStorage.getItem('authToken')) {
        loadConfiguration(); // populate form with current settings
        checkStatus(); // get initial system status
        loadTrades(); // load trading history
        setupDynamicRefresh(); // start periodic updates
        console.log('‚úÖ Main application initialized');
    }
});

/**
 * Setup refresh intervals that adapt to backend loop timing
 * Creates responsive UI that syncs with backend update frequency
 */
async function setupDynamicRefresh() {
    await updateLoopInterval(); // get current backend timing
    statusCheckInterval = setInterval(checkStatus, 10000); // check status every 10s
    setupTradesRefresh(); // setup trades refresh based on loop interval
    setInterval(updateLoopInterval, 120000); // update timing every 2 minutes
    console.log(`‚è±Ô∏è Dynamic refresh setup complete`);
}

/**
 * Update loop interval from backend configuration
 * Syncs frontend refresh rates with backend processing speed
 */
async function updateLoopInterval() {
    try {
        const response = await authenticatedFetch(`${API_BASE_URL}/parameters`);
        if (response.ok) {
            const data = await response.json();
            if (data.current_parameters && data.current_parameters.loop_interval) {
                const newInterval = data.current_parameters.loop_interval;
                if (newInterval !== currentLoopInterval) {
                    console.log(`‚è±Ô∏è Loop interval updated: ${currentLoopInterval}s ‚Üí ${newInterval}s`);
                    currentLoopInterval = newInterval;
                    setupTradesRefresh(); // adjust refresh rate
                }
            }
        }
    } catch (error) {
        console.log('üìä Using default loop interval:', currentLoopInterval);
    }
}

/**
 * Setup trades refresh interval based on backend loop timing
 * Optimizes refresh frequency to match data update rate
 */
function setupTradesRefresh() {
    if (tradesRefreshInterval) {
        clearInterval(tradesRefreshInterval); // clear existing interval
    }
    const refreshRate = (currentLoopInterval + 10) * 1000; // add 10s buffer
    tradesRefreshInterval = setInterval(loadTrades, refreshRate);
    console.log(`üìà Trades refresh: every ${currentLoopInterval + 10}s`);
}

/**
 * Check bot status and update UI accordingly
 * Provides real-time feedback on system health and trading state
 */
async function checkStatus() {
    try {
        const response = await authenticatedFetch(`${API_BASE_URL}/status`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        updateStatusDisplay(data); // update UI elements
        hideMessage('controlMessage'); // clear any error messages
        
    } catch (error) {
        console.error('üì° Status check error:', error);
        handleStatusError(); // show offline state
    }
}

/**
 * Update status display based on backend response
 * Translates backend status into user-friendly UI states
 */
function updateStatusDisplay(data) {
    const statusText = document.getElementById('statusText');
    const statusIndicator = document.getElementById('statusIndicator');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    
    if (data.status === 'running') {
        // show different messages based on indicator availability
        if (data.indicators && !data.indicators.available) {
            const current = data.data_stats?.total_records || 0;
            const required = data.indicators.min_required || 26;
            statusText.textContent = `Collecting data (${current}/${required})`;
        } else {
            statusText.textContent = `Running - Updates every ${currentLoopInterval}s`;
        }
        
        // update UI for running state
        statusIndicator.classList.add('running');
        startBtn.disabled = true;
        stopBtn.disabled = false;
    } else {
        // update UI for stopped state
        statusText.textContent = 'Stopped';
        statusIndicator.classList.remove('running');
        startBtn.disabled = false;
        stopBtn.disabled = true;
    }
}

/**
 * Handle status check errors - backend offline scenario
 * Provides helpful feedback when backend is not running
 */
function handleStatusError() {
    document.getElementById('statusText').textContent = 'Backend Offline';
    document.getElementById('statusIndicator').classList.remove('running');
    
    // throttle connection error messages to avoid spam
    if (!lastConnectionCheck || Date.now() - lastConnectionCheck > 30000) {
        showMessage('controlMessage', 'Backend not running. Start Python backend (main.py) to connect.', 'warning');
        lastConnectionCheck = Date.now();
    }
    
    // enable start button for user feedback
    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
}

/**
 * Load recent trades and update table display
 * Fetches and displays trading history with formatting
 */
async function loadTrades() {
    try {
        const response = await authenticatedFetch(`${API_BASE_URL}/trades`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        updateTradesTable(data.trades); // update table with new data
        
        if (data.trades && data.trades.length > 0) {
            console.log(`üìà Trades updated: ${data.trades.length} trades`);
        }
        
    } catch (error) {
        console.log('üìà Trades not available:', error.message);
    }
}

/**
 * Update trades table with formatted trade data
 * Creates user-friendly table display with proper formatting
 */
function updateTradesTable(trades) {
    const tableBody = document.getElementById('tradesTableBody');
    tableBody.innerHTML = '';
    
    // show empty state if no trades
    if (!trades || trades.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5" style="text-align: center; color: #64748b;">No trades yet</td>';
        tableBody.appendChild(row);
        return;
    }
    
    // display trades in reverse order (newest first)
    trades.reverse().forEach(trade => {
        const row = document.createElement('tr');
        const formattedDate = new Date(trade.datetime).toLocaleString();
        const sideClass = trade.side.toLowerCase();
        const formattedPrice = `${trade.price.toLocaleString('en-US', {
            minimumFractionDigits: 2, 
            maximumFractionDigits: 2
        })}`;
        
        // create styled table row with color-coded trade sides
        row.innerHTML = `
            <td>${formattedDate}</td>
            <td><span class="trade-side ${sideClass}">${trade.side}</span></td>
            <td>${formattedPrice}</td>
            <td>${trade.quantity.toFixed(6)}</td>
            <td>${trade.trade_size.toFixed(6)}</td>
        `;
        tableBody.appendChild(row);
    });
}

/**
 * Start bot function - provides user guidance
 * Bot starts automatically with Python backend, this provides instruction
 */
function startBot() {
    showMessage('controlMessage', 'The bot starts automatically when you run the Python backend (main.py)', 'warning');
}

/**
 * Stop bot by sending shutdown signal to backend
 * Gracefully stops trading operations and backend server
 */
async function stopBot() {
    const stopBtn = document.getElementById('stopBtn');
    const stopText = document.getElementById('stopText');
    
    stopBtn.disabled = true;
    stopText.innerHTML = '<span class="loading"></span> Stopping...'; // loading indicator
    
    try {
        const response = await authenticatedFetch(`${API_BASE_URL}/end`, {
            method: 'POST'
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        showMessage('controlMessage', 'Bot shutdown initiated!', 'success');
        
        // cleanup intervals since backend is stopping
        if (statusCheckInterval) clearInterval(statusCheckInterval);
        if (tradesRefreshInterval) clearInterval(tradesRefreshInterval);
        
        // update UI to reflect stopped state
        setTimeout(() => {
            document.getElementById('statusText').textContent = 'Stopped';
            document.getElementById('statusIndicator').classList.remove('running');
            stopBtn.disabled = true;
            document.getElementById('startBtn').disabled = false;
        }, 1000);
        
    } catch (error) {
        showMessage('controlMessage', 'Failed to stop bot', 'error');
    } finally {
        // reset button state after delay
        setTimeout(() => {
            stopBtn.disabled = false;
            stopText.textContent = 'Stop Bot';
        }, 3000);
    }
}

/**
 * Load configuration from backend and populate form
 * Syncs frontend form with current backend settings
 */
async function loadConfiguration() {
    try {
        console.log('‚öôÔ∏è Loading configuration...');
        const response = await authenticatedFetch(`${API_BASE_URL}/parameters`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.current_parameters) {
            populateFormFields(data.current_parameters); // fill form with current values
            if (data.current_parameters.loop_interval) {
                currentLoopInterval = data.current_parameters.loop_interval;
            }
            console.log('‚úÖ Configuration loaded');
        } else {
            resetToDefaults(); // use defaults if no config found
        }
    } catch (error) {
        console.log('‚öôÔ∏è Could not load configuration, using defaults');
        resetToDefaults();
    }
}

/**
 * Populate form fields with parameter values
 * Maps backend configuration to form inputs with proper formatting
 */
function populateFormFields(params) {
    document.getElementById('tradeSize').value = params.trade_size || DEFAULT_CONFIG.tradeSize;
    document.getElementById('stopLoss').value = ((params.stop_loss || DEFAULT_CONFIG.stopLoss / 100) * 100).toFixed(1); // convert to percentage
    document.getElementById('stopProfit').value = ((params.stop_profit || DEFAULT_CONFIG.stopProfit / 100) * 100).toFixed(1); // convert to percentage
    document.getElementById('rsiBuy').value = params.rsi_buy_threshold || DEFAULT_CONFIG.rsiBuy;
    document.getElementById('rsiSell').value = params.rsi_sell_threshold || DEFAULT_CONFIG.rsiSell;
    document.getElementById('macdBuy').value = params.macd_buy_threshold || DEFAULT_CONFIG.macdBuy;
    document.getElementById('macdSell').value = params.macd_sell_threshold || DEFAULT_CONFIG.macdSell;
    document.getElementById('positionSize').value = params.position_size_usdt || DEFAULT_CONFIG.positionSize;
    document.getElementById('loopInterval').value = params.loop_interval || DEFAULT_CONFIG.loopInterval;
    document.getElementById('indicatorWindow').value = params.indicator_window || DEFAULT_CONFIG.indicatorWindow;
    document.getElementById('active').value = params.active ? 1 : 0; // boolean to integer conversion
}

/**
 * Reset form to default configuration values
 * Provides easy way to restore recommended settings
 */
function resetToDefaults() {
    document.getElementById('tradeSize').value = DEFAULT_CONFIG.tradeSize;
    document.getElementById('stopLoss').value = DEFAULT_CONFIG.stopLoss;
    document.getElementById('stopProfit').value = DEFAULT_CONFIG.stopProfit;
    document.getElementById('rsiBuy').value = DEFAULT_CONFIG.rsiBuy;
    document.getElementById('rsiSell').value = DEFAULT_CONFIG.rsiSell;
    document.getElementById('macdBuy').value = DEFAULT_CONFIG.macdBuy;
    document.getElementById('macdSell').value = DEFAULT_CONFIG.macdSell;
    document.getElementById('positionSize').value = DEFAULT_CONFIG.positionSize;
    document.getElementById('loopInterval').value = DEFAULT_CONFIG.loopInterval;
    document.getElementById('indicatorWindow').value = DEFAULT_CONFIG.indicatorWindow;
    document.getElementById('active').value = DEFAULT_CONFIG.active;
    
    showMessage('configMessage', 'Configuration reset to default values', 'success');
}

/**
 * Save configuration to backend with validation
 * Validates form data and sends to backend for persistence
 */
async function saveConfiguration() {
    const saveText = document.getElementById('saveText');
    const originalText = saveText.textContent;
    
    saveText.innerHTML = '<span class="loading"></span> Saving...'; // loading state
    
    try {
        const config = getFormConfiguration(); // extract form data

        if (!validateConfiguration(config)) {
            return; // validation failed, don't proceed
        }

        console.log('üíæ Saving configuration...', config);
        const response = await authenticatedFetch(`${API_BASE_URL}/save-config`, {
            method: 'POST',
            body: JSON.stringify(config)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP ${response.status}`);
        }

        // update refresh intervals if timing changed
        if (config.loop_interval !== currentLoopInterval) {
            currentLoopInterval = config.loop_interval;
            setTimeout(() => {
                setupDynamicRefresh(); // restart with new timing
            }, 1000);
        }
        
        showMessage('configMessage', 'Configuration saved successfully!', 'success');
        console.log('‚úÖ Configuration saved');
        
    } catch (error) {
        console.error('‚ùå Save configuration error:', error);
        showMessage('configMessage', `Failed to save: ${error.message}`, 'error');
    } finally {
        saveText.textContent = originalText; // restore button text
    }
}

/**
 * Extract configuration from form inputs
 * Collects and formats form data for backend submission
 */
function getFormConfiguration() {
    return {
        trade_size: parseFloat(document.getElementById('tradeSize').value),
        stop_loss: parseFloat(document.getElementById('stopLoss').value) / 100, // convert percentage to decimal
        stop_profit: parseFloat(document.getElementById('stopProfit').value) / 100, // convert percentage to decimal
        rsi_buy_threshold: parseInt(document.getElementById('rsiBuy').value),
        rsi_sell_threshold: parseInt(document.getElementById('rsiSell').value),
        macd_buy_threshold: parseFloat(document.getElementById('macdBuy').value),
        macd_sell_threshold: parseFloat(document.getElementById('macdSell').value),
        position_size_usdt: parseFloat(document.getElementById('positionSize').value),
        loop_interval: parseInt(document.getElementById('loopInterval').value),
        indicator_window: parseInt(document.getElementById('indicatorWindow').value),
        active: parseInt(document.getElementById('active').value)
    };
}

/**
 * Validate configuration values before saving
 * Ensures form data is valid and logically consistent
 */
function validateConfiguration(config) {
    // check for NaN values that could break the backend
    for (const [key, value] of Object.entries(config)) {
        if (isNaN(value)) {
            showMessage('configMessage', `Invalid value for ${key}`, 'error');
            return false;
        }
    }

    // logical validation - RSI thresholds must make sense
    if (config.rsi_buy_threshold >= config.rsi_sell_threshold) {
        showMessage('configMessage', 'RSI buy threshold must be less than sell threshold', 'error');
        return false;
    }
    
    // ensure positive values for risk management
    if (config.stop_loss <= 0 || config.stop_profit <= 0) {
        showMessage('configMessage', 'Stop loss and take profit must be greater than 0', 'error');
        return false;
    }
    
    return true;
}

/**
 * Show user feedback messages in UI
 * Provides consistent message display across the application
 */
function showMessage(elementId, text, type) {
    const messageDiv = document.getElementById(elementId);
    if (messageDiv) {
        messageDiv.textContent = text;
        messageDiv.className = `message ${type}`;
        messageDiv.style.display = 'block';
        
        // auto-hide success messages after 8 seconds
        if (type === 'success') {
            setTimeout(() => hideMessage(elementId), 8000);
        }
    }
}

/**
 * Hide message elements
 * Clears user feedback messages from display
 */
function hideMessage(elementId) {
    const messageDiv = document.getElementById(elementId);
    if (messageDiv) {
        messageDiv.style.display = 'none';
    }
}

console.log('üöÄ Main application script with authentication loaded!');