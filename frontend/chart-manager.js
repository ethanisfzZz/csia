/**
 *  THIS FILE WAS GENERATED BY FIGMA'S DESIGN-TO-CODE PLUGIN, WITH FILE DESTINATIONS INCLUDED AFTERWARDS
 * 
 *  Chart manager with authentication support
 * 
 * 
 * Citations:
 * - Plotly.js charting library: https://plotly.com/javascript/
 * - Fetch API for HTTP requests: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
 * - ES6 Classes: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
 * - SessionStorage API: https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
 */
class TradingChartManager {
    constructor(apiBaseUrl = 'http://localhost:5000') {
        this.marketData = [];
        this.tradeData = [];
        this.API_BASE_URL = apiBaseUrl;
        this.chartInitialized = false;
        this.minDataForIndicators = 26; // default MACD period
        
        console.log('📊 TradingChartManager initialized with auth');
    }

    /**
     * Get authentication headers for API calls
     * Retrieves stored JWT token from session storage
     */
    getAuthHeaders() {
        const token = sessionStorage.getItem('authToken');
        return {
            'Authorization': `Bearer ${token}`
        };
    }

    /**
     * Make authenticated API request with automatic redirect on auth failure
     * Handles 401 responses by redirecting to login page
     */
    async authenticatedFetch(url) {
        const response = await fetch(url, {
            headers: this.getAuthHeaders()
        });
        
        // handle authentication failure gracefully
        if (response.status === 401) {
            console.log('🔐 Chart auth failed, redirecting...');
            sessionStorage.removeItem('authToken'); // clean up invalid token
            window.location.href = 'login.html';
            throw new Error('Authentication failed');
        }
        
        return response;
    }

    /**
     * Initialize the chart system - entry point for chart setup
     * Waits for DOM ready state before starting
     */
    async initialize() {
        console.log('🚀 Starting chart initialization...');
        
        // ensure DOM is ready before manipulating elements
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.startChart());
        } else {
            this.startChart();
        }
    }

    /**
     * Start chart creation and data loading
     * Coordinates the entire chart setup process
     */
    startChart() {
        console.log('🎯 Starting chart system...');
        
        // wait for Plotly library to load before creating charts
        this.waitForPlotly().then(() => {
            this.createInitialChart();
            this.setupDataRefresh(); // start periodic updates
        }).catch(() => {
            this.createFallbackChart(); // fallback if Plotly fails to load
        });
    }

    /**
     * Wait for Plotly library to load with timeout
     * Polling approach to detect when external library is ready
     */
    waitForPlotly(timeout = 10000) {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            const checkPlotly = () => {
                if (typeof Plotly !== 'undefined') {
                    console.log('✅ Plotly loaded successfully');
                    resolve();
                } else if (Date.now() - startTime > timeout) {
                    console.error('❌ Plotly failed to load');
                    reject();
                } else {
                    setTimeout(checkPlotly, 100); // check every 100ms
                }
            };
            
            checkPlotly();
        });
    }

    /**
     * Create initial chart after loading all required data
     * Main chart creation orchestrator
     */
    async createInitialChart() {
        const container = document.getElementById('priceChart');
        if (!container) {
            console.error('❌ Chart container not found');
            return;
        }

        await this.loadAllData(); // load all required data first
        this.updateChart(); // create appropriate chart based on data availability
        this.chartInitialized = true;
    }

    /**
     * Load all data required for chart creation
     * Coordinates loading of parameters, market data, and trades
     */
    async loadAllData() {
        try {
            await this.loadMinRequiredData(); // get minimum data requirements
            await this.loadMarketData(); // load price and indicator data
            await this.loadTradesData(); // load trading history
        } catch (error) {
            console.log('📡 Error loading chart data:', error);
        }
    }

    /**
     * Get minimum required data points for indicators
     * Fetches configuration to determine when indicators become available
     */
    async loadMinRequiredData() {
        try {
            const response = await this.authenticatedFetch(`${this.API_BASE_URL}/parameters`);
            if (response.ok) {
                const data = await response.json();
                if (data.derived_periods) {
                    // calculate minimum data needed for all indicators
                    this.minDataForIndicators = Math.max(
                        data.derived_periods.rsi_window,
                        data.derived_periods.macd_slow,
                        data.derived_periods.signal_window
                    );
                    console.log(`📊 Min data points: ${this.minDataForIndicators}`);
                }
            }
        } catch (error) {
            console.log('📊 Using default min data:', this.minDataForIndicators);
        }
    }

    /**
     * Load market data from backend API
     * Fetches price, volume, and technical indicator data
     */
    async loadMarketData() {
        try {
            const response = await this.authenticatedFetch(`${this.API_BASE_URL}/market-data`);
            if (response.ok) {
                const result = await response.json();
                this.marketData = result.data || [];
                console.log(`📊 Loaded ${this.marketData.length} market data points`);
            } else {
                this.marketData = [];
            }
        } catch (error) {
            console.log('📊 Could not load market data');
            this.marketData = [];
        }
    }

    /**
     * Load trades data for displaying buy/sell markers on chart
     * Fetches trading history to show execution points
     */
    async loadTradesData() {
        try {
            const response = await this.authenticatedFetch(`${this.API_BASE_URL}/trades`);
            if (response.ok) {
                const result = await response.json();
                this.tradeData = result.trades || [];
                console.log(`📈 Loaded ${this.tradeData.length} trades`);
            } else {
                this.tradeData = [];
            }
        } catch (error) {
            console.log('📈 Could not load trades data');
            this.tradeData = [];
        }
    }

    /**
     * Update chart based on data availability
     * Shows different chart states based on data completeness
     */
    updateChart() {
        const container = document.getElementById('priceChart');
        if (!container) return;

        // determine appropriate chart type based on data availability
        if (this.marketData.length === 0) {
            this.showNoDataState();
        } else if (this.marketData.length < this.minDataForIndicators) {
            this.showInsufficientDataState(); // price only, no indicators yet
        } else {
            this.showFullTradingChart(); // complete chart with indicators and trades
        }
    }

    /**
     * Display state when no data is available
     * Shows user-friendly message encouraging backend startup
     */
    showNoDataState() {
        console.log('📊 No data available');
        
        const container = document.getElementById('priceChart');
        // create informative placeholder with styling
        container.innerHTML = `
            <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 400px;
                background: rgba(15, 23, 42, 0.5);
                border: 2px dashed rgba(239, 68, 68, 0.4);
                border-radius: 12px;
                color: #e2e8f0;
                text-align: center;
                padding: 30px;
            ">
                <div style="font-size: 48px; margin-bottom: 20px;">📊</div>
                <div style="font-size: 20px; font-weight: 600; margin-bottom: 15px; color: #ef4444;">
                    No Price Data Available
                </div>
                <div style="font-size: 14px; color: #94a3b8; line-height: 1.5;">
                    Start the Python backend to begin collecting data
                </div>
            </div>
        `;
        
        this.showMessage('No price data found', 'error');
    }

    /**
     * Display state when insufficient data for indicators
     * Shows price chart only while collecting more data
     */
    showInsufficientDataState() {
        console.log(`📊 Insufficient data: ${this.marketData.length}/${this.minDataForIndicators}`);
        
        // fallback to basic chart if Plotly not available
        if (typeof Plotly === 'undefined') {
            this.createFallbackChart();
            return;
        }

        // extract time series data for plotting
        const timestamps = this.marketData.map(d => new Date(d.datetime));
        const prices = this.marketData.map(d => d.price);

        // create simple price trace
        const priceTrace = {
            x: timestamps,
            y: prices,
            type: 'scatter',
            mode: 'lines+markers',
            name: 'BTC Price',
            line: { color: '#ff6b6b', width: 2 },
            marker: { color: '#ff6b6b', size: 4 }
        };

        // configure chart layout with dark theme
        const layout = {
            title: {
                text: `Bitcoin Price Data (${this.marketData.length}/${this.minDataForIndicators} for indicators)`,
                font: { color: '#e2e8f0' }
            },
            xaxis: { 
                title: 'Time', 
                color: '#e2e8f0',
                gridcolor: 'rgba(71, 85, 105, 0.3)',
                type: 'date'
            },
            yaxis: { 
                title: 'Price (USD)', 
                color: '#e2e8f0',
                gridcolor: 'rgba(71, 85, 105, 0.3)'
            },
            paper_bgcolor: 'rgba(0,0,0,0)', // transparent background
            plot_bgcolor: 'rgba(15, 23, 42, 0.3)',
            font: { color: '#e2e8f0' },
            margin: { t: 60, r: 30, b: 60, l: 70 },
            height: 400
        };

        // create static chart while collecting data
        Plotly.newPlot('priceChart', [priceTrace], layout, {
            responsive: true,
            displayModeBar: false,
            staticPlot: true
        })
        .then(() => {
            console.log('✅ Price chart created');
            this.showMessage(`Need ${this.minDataForIndicators - this.marketData.length} more data points for indicators`, 'warning');
        })
        .catch(error => {
            console.error('❌ Chart error:', error);
            this.createFallbackChart();
        });
    }

    /**
     * Display full trading chart with price data and trade markers
     * Complete chart showing price action and trading activity
     */
    showFullTradingChart() {
        console.log(`📊 Full chart: ${this.marketData.length} data, ${this.tradeData.length} trades`);
        
        if (typeof Plotly === 'undefined') {
            this.createFallbackChart();
            return;
        }

        const traces = [];
        const timestamps = this.marketData.map(d => new Date(d.datetime));
        const prices = this.marketData.map(d => d.price);

        // add main price line
        traces.push({
            x: timestamps,
            y: prices,
            type: 'scatter',
            mode: 'lines',
            name: 'BTC Price',
            line: { color: '#ff6b6b', width: 2 }
        });

        // add trade markers if available
        if (this.tradeData.length > 0) {
            const buyTrades = this.tradeData.filter(t => t.side === 'BUY');
            const sellTrades = this.tradeData.filter(t => t.side === 'SELL');

            // add buy trade markers
            if (buyTrades.length > 0) {
                traces.push({
                    x: buyTrades.map(t => new Date(t.datetime)),
                    y: buyTrades.map(t => t.price),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Buy Orders',
                    marker: { color: '#10b981', size: 12, symbol: 'triangle-up' }
                });
            }

            // add sell trade markers
            if (sellTrades.length > 0) {
                traces.push({
                    x: sellTrades.map(t => new Date(t.datetime)),
                    y: sellTrades.map(t => t.price),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Sell Orders',
                    marker: { color: '#ef4444', size: 12, symbol: 'triangle-down' }
                });
            }
        }

        // full chart layout with legend
        const layout = {
            title: {
                text: 'Bitcoin Trading Dashboard - Live Data',
                font: { color: '#e2e8f0' }
            },
            xaxis: { 
                title: 'Time', 
                color: '#e2e8f0',
                gridcolor: 'rgba(71, 85, 105, 0.3)',
                type: 'date'
            },
            yaxis: { 
                title: 'Price (USD)', 
                color: '#e2e8f0',
                gridcolor: 'rgba(71, 85, 105, 0.3)'
            },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(15, 23, 42, 0.3)',
            font: { color: '#e2e8f0' },
            legend: { font: { color: '#e2e8f0' } },
            margin: { t: 60, r: 30, b: 60, l: 70 },
            height: 400,
            showlegend: true
        };

        // create interactive chart
        Plotly.newPlot('priceChart', traces, layout, {
            responsive: true,
            displayModeBar: false,
            staticPlot: true
        })
        .then(() => {
            console.log('✅ Full trading chart created');
            this.showMessage(`Chart active: ${this.marketData.length} data points, ${this.tradeData.length} trades`, 'success');
        })
        .catch(error => {
            console.error('❌ Chart error:', error);
            this.createFallbackChart();
        });
    }

    /**
     * Fallback chart when Plotly fails to load
     * Provides user feedback when charting library is unavailable
     */
    createFallbackChart() {
        const container = document.getElementById('priceChart');
        if (!container) return;

        container.innerHTML = `
            <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 400px;
                background: rgba(15, 23, 42, 0.5);
                border: 2px dashed rgba(99, 102, 241, 0.4);
                border-radius: 12px;
                color: #e2e8f0;
                text-align: center;
                padding: 30px;
            ">
                <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
                <div style="font-size: 20px; font-weight: 600; margin-bottom: 15px;">
                    Chart Library Loading...
                </div>
                <div style="font-size: 14px; color: #94a3b8;">
                    Please wait for Plotly to load
                </div>
            </div>
        `;
    }

    /**
     * Setup automatic data refresh every 30 seconds
     * Keeps chart data current without manual refresh
     */
    setupDataRefresh() {
        setInterval(() => {
            if (this.chartInitialized) {
                this.refreshData();
            }
        }, 30000); // refresh every 30 seconds
        
        console.log('🔄 Chart refresh: every 30s');
    }

    /**
     * Refresh chart data and update display if changes detected
     * Compares data lengths to determine if update is needed
     */
    async refreshData() {
        console.log('🔄 Refreshing chart data...');
        
        const previousDataLength = this.marketData.length;
        const previousTradesLength = this.tradeData.length;
        
        await this.loadAllData(); // reload all data
        
        // only update chart if data actually changed
        if (this.marketData.length !== previousDataLength || 
            this.tradeData.length !== previousTradesLength) {
            console.log(`📊 Chart data updated`);
            this.updateChart();
        }
    }

    /**
     * Show user feedback messages
     * Displays status messages in the UI message container
     */
    showMessage(text, type) {
        const messageDiv = document.getElementById('vizMessage');
        if (messageDiv) {
            messageDiv.textContent = text;
            messageDiv.className = `message ${type}`;
            messageDiv.style.display = 'block';
            
            // auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    messageDiv.style.display = 'none';
                }, 5000);
            }
        }
    }

    /**
     * Manual refresh triggered by user action
     * Provides immediate chart update on demand
     */
    async refresh() {
        console.log('🔄 Manual chart refresh...');
        this.showMessage('Refreshing chart...', 'warning');
        await this.refreshData();
    }
}

// Global functions for external access
let chartManagerInstance = null;

// initialize chart manager - called from main page
window.initializeChartManager = function(apiBaseUrl = 'http://localhost:5000') {
    console.log('🎯 Initializing chart manager...');
    chartManagerInstance = new TradingChartManager(apiBaseUrl);
    chartManagerInstance.initialize();
    return chartManagerInstance;
};

// manual refresh function - can be called from UI buttons
window.refreshChart = function() {
    if (chartManagerInstance) {
        chartManagerInstance.refresh();
    } else {
        console.warn('Chart manager not initialized');
    }
};

console.log('🚀 Chart manager with authentication loaded!');